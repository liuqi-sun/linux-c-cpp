1、c++内联函数
内联函数和普通函数相比较可以加快程序运行速度，因为不需要中断调用，调用会涉及到一些开销，比如在ARM架构上需要用R14寄存器保存当前PC，然后执行跳转指令跳转，调用结束后，需要恢复R14的值。在编译的时候，在程序的每个调用的地方展开（和宏很像）。
一般来说内联函数适用于优化小的、只有几行的而且经常被调用的函数。
c、c++程序员面试宝典中，说道的不宜使用内联函数的情况：1 如果函数体内的代码比较长，使用内联将导致内存消耗代
价较高。2 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。针对2容易误解，包括查看互联网上的提问也有类似的问题，
某网友--1）我能理解。但对于（2）
内联函数体内出现循环，那么执行函数体内代码的时间为什么要比函数调用的开销大。
函数调用多了保护现场跟恢复现场，然后要执行函数体。
用内联函数 就直接执行函数体，牺牲点空间而已。
为什么这里说 执行函数体内代码的时间要比函数调用的开销大

我的意思是函数无论是不是内联，函数体代码都要去执行的。为什么
如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
函数调用，也要去执行函数体内代码啊。另外，还多了调用的开销。
不可能行函数体内代码的时间要比函数调用的开销大
--------
我认为c c++面试宝典的作者的意思是函数体内出现循环或者执行逻辑比较长，执行函数体时间要远大于函数调用的开销，可以忽略函数调用华为的时间，把内存开销作为首要考虑点，所以这种情况不适合用内联。

2、内存中的数据对齐
在默认情况下，为了方便对结构体内元素的访问和管理，当结构
体内的元素的长度都小于处理器的位数的时候，便以结构体里面最长的数据元素为对齐单
位，也就是说，结构体的长度一定是最长的数据元素的整数倍。如果结构体内存在长度大于
处理器位数的元素，那么就以处理器的位数为对齐单位。但是结构体内类型相同的连续元素
将在连续的空间内，和数组一样。

本人机器64位的，8字节。测试如下结构体：
struct B {
    char a;
    char b;
    char c;
};//size 为3

struct B {
    short a;
    short b;
    short c;
};//size 为6

struct B {
    short a;
    char e;
;

};//size 为4

struct B {
    short a;
    short b;
    short c;
    char e;
    char f;
    char g;

};//size 为10

struct B {
/*    short a;
    short b;
    short c;
    char e;
    char f;
    char g;*/

    long a;
    int b;
    char c;

};//size 为16

struct B {
/*    short a;
    short b;
    short c;
    char e;
    char f;
    char g;*/

    short a;
    int  b;
    char c;

};//size 为12

